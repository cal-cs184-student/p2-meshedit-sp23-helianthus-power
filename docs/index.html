<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <style>
        body {
            background-color: white;
            padding: 100px;
            width: 1000px;
            margin: auto;
            text-align: left;
            font-weight: 300;
            font-family: 'Open Sans', sans-serif;
            color: #121212;
        }

        h1, h2, h3, h4 {
            font-family: 'Source Sans Pro', sans-serif;
        }

        kbd {
            color: #121212;
        }
    </style>
    <title>CS 184 Mesh Edit</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet" />

    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            }
        };
    </script>
    <script id="MathJax-script" async=async
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
    </script>
    




</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2018</h1>
<h1 align="middle">Project 2: Mesh Edit</h1>
<h2 align="middle">Ziqi Shi, Buyi Geng</h2>

<br><br>

    <div>

        <h2 align="middle">Overview</h2>
        <p>
            YOUR RESPONSE GOES HERE
        </p>



        <br />


        <h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

        <h3 align="middle">Part 1: Bezier Curves with 1D de Casteljau Subdivision</h3>


        <p>
            De Casteljau's algorithm is a recursive method used to evaluate points on a Bezier curve. It works by repeatedly dividing a Bezier curve into smaller segments, until each segment is just a straight line. At this point, the algorithm can directly compute the point on the curve that corresponds to a given parameter value.
            Given <b>n</b> (possibly intermediate) control points <b>p<SUB>1</SUB>, ..., p<SUB>n</SUB></b> and the parameter <b>t</b>, we use linear interpolation to compute the <b>nâˆ’1</b> intermediate control points at the parameter <b>t</b> in the next subdivision level, <b>p<SUB>1</SUB><SUP>'</SUP>,...,p<SUB>n</SUB><SUP>'</SUP></b>.
        </p>

        <p>
            To use de Casteljau's algorithm to evaluate a Bezier curve, we start with the control points that define the curve. We then compute a series of intermediate points, known as "control points of the next degree," by interpolating between adjacent control points. We repeat this process recursively, each time using the previously computed points as the new control points, until we have computed a single point, which is the point on the curve corresponding to the given parameter value.
        </p>
        <br />


        <b>
            Take a look at the provided .bzc files and create your own Bezier curve with 6 control points of your choosing. Use this Bezier curve for your screenshots below.
        </b>
        <p>
            The screenshot for the curve2 we define is below:
        </p>
        <!-- Example of including a single figure -->
        <div align="middle">
            <img src="image2/curve2.png" align="middle" width="50%" />
        </div>
        <br />

        <b>
            Show screenshots of each step / level of the evaluation from the original control points down to the final evaluated point. Press <kbd>E</kbd> to step through. Toggle <kbd>C</kbd> to show the completed Bezier curve as well.
        </b>
        <!-- Example of including multiple figures -->
        <div align="middle">
            <table style="width:100%">
                <tr align="center">
                    <td>
                        <img src="image2/level0.png" align="middle" width="400px" />
                        <figcaption>Level 0</figcaption>
                    </td>
                    <td>
                        <img src="image2/level1.png" align="middle" width="400px" />
                        <figcaption>Level 1</figcaption>
                    </td>
                </tr>
                <br />
                <tr align="center">
                    <td>
                        <img src="image2/level2.png" align="middle" width="400px" />
                        <figcaption>Level 2</figcaption>
                    </td>
                    <td>
                        <img src="image2/level3.png" align="middle" width="400px" />
                        <figcaption>Level 3</figcaption>
                    </td>
                </tr>
                <br />
                <tr align="center">
                    <td>
                        <img src="image2/level4.png" align="middle" width="400px" />
                        <figcaption>Level 4</figcaption>
                    </td>
                </tr>
            </table>
        </div>
        <br />


        <b>
            Show a screenshot of a slightly different Bezier curve by moving the original control points around and modifying the parameter \(t\) via mouse scrolling.
        </b>



        <b>
            The screenshot for the curve2 we define is below:
        </b>

        <div align="middle">
            <img src="image2/df new.png" align="middle" width="50%" />
        </div>

        <p>
            The screenshot of a slightly different Bezier curve is:
        </p>
        <div align="middle">
            <img src="image2/different curve.png" align="middle" width="50%" />
        </div>



        <br />


        <h3 align="middle">Part 2: Bezier Surfaces with Separable 1D de Casteljau</h3>
        <p>
            For Part 2, we adapted the 1D de Casteljau algorithm used for Bezier curves to work for Bezier surfaces. We used a separable approach, where we first evaluated Bezier curves along each row and then evaluated a final Bezier curve along the resulting column of points.
        </p>
        <p>
            In practice, we implemented three parts in student_code.cpp: BezierPatch::evaluateStep(...),BezierPatch::evaluate1D(...),BezierPatch::evaluate(...).
         </p>
        <p>    
            To evaluate a point on a Bezier surface at a given (u,v) parameter, we first evaluate a set of intermediate control points for each row using de Casteljau's algorithm with the u parameter. Then, we evaluate the final control points for each column using de Casteljau's algorithm with the v parameter, using the intermediate control points obtained in the previous step as input.We implemented this algorithm in the BezierPatch::evaluateStep(...) function, which computes intermediate control points for a given parameter along a single row or column. We also implemented the BezierPatch::evaluate1D(...) function, which directly computes the final point on a single Bezier curve along a row or column. Finally, we implemented the BezierPatch::evaluate(...) function, which computes the final point on the Bezier surface at a given (u,v) parameter by calling BezierPatch::evaluate1D(...) on each row and column of control points.

        </p>

        <p>
            We used std::vector to store control points, which made it easy to access and manipulate control points for each row and column. We also used the push_back() function to append intermediate control points to a std::vector.
        </p>
        <br />


        <b>
            Show a screenshot of bez/teapot.bez (not .dae) evaluated by your implementation.
        </b>
        <p>
            YOUR RESPONSE GOES HERE
        </p>
        <br />


        <h2 align="middle">Section II: Triangle Meshes and Half-Edge Data Structure</h2>

        <h3 align="middle">Part 3: Area-Weighted Vertex Normals</h3>

        <b>
            We used half-edge data structure to iterate through faces(triangles) incident to the vertex,i.e.,faces that have the given vertex as one of its vertices.For each such face, the weight is normal bt its area. In the last step,we normalized the sum of all area-weighted normals.
        </b>
        <p>
            The part we implemented is Vertex::normal() in student_code.cpp.
        </p>
        <br />


        <b>
            Show screenshots of dae/teapot.dae (not .bez) comparing teapot shading with and without vertex normals. Use <kbd>Q</kbd> to toggle default flat shading and Phong shading.
        </b>

        <div align="middle">
            <table style="width:100%">
                <tr align="center">
                    <td>
                        <img src="image2/dae1.png" align="middle" width="400px" />
                        <figcaption> Without vertex normal</figcaption>
                    </td>
                    <td>
                        <img src="image2/dae2.png" align="middle" width="400px" />
                        <figcaption> With vertex normal</figcaption>
                    </td>
                </tr>

          
            </table>
        </div>

        <p>
            YOUR RESPONSE GOES HERE
        </p>
        <br />


        <h3 align="middle">Part 4: Edge Flip</h3>
        <p>
            We implemented HalfedgeMesh::flipEdge(...) in student_code.cpp following the steps outlined in the prompt.
            First, check if the edge was a boundary edge by checking if either of the neighboring faces was on a boundary loop. If it's a boundary edge, return immediately. If it's not a boundary edge, find the four half-edges invovled in the flip(the two half-edges on either side of the edge being flipped, and the two half-edges on the other side of those two half-edges).
            Then, update the pointers of the four half-edges to reflect the new mesh structure. We used Halfedge::setNeighbors(...) to set all the pointers of a half-edge at once. Then update the pointers of the neighboring vertices, edges and faces. In the end, return a pointer to the new flipped edge.
        </p>
        <p>
            To ensure that all pointers of all elements were still valid after the edge flip, we follow the steps outlined in the prompt. We drew a simple mesh and wrote down a list of all elements,then drew the mesh after the flip and wrote down a list of all elements in the modified mesh, not just the ones that had changed, to avoid missing a pointer.

        </p>


        <br />


        <b>
            Show screenshots of the teapot before and after some edge flips.
        </b>

        <div align="middle">
            <table style="width:100%">
                <tr align="center">
                    <td>
                        <img src="image2/level0.png" align="middle" width="400px" />
                        <figcaption>Level 0</figcaption>
                    </td>
                    <td>
                        <img src="image2/level1.png" align="middle" width="400px" />
                        <figcaption>Level 1</figcaption>
                    </td>
                </tr>
            </table>
        </div>
        <br />


        <p>
            YOUR RESPONSE GOES HERE
        </p>
        <br />


        <b>
            We did not encounter major issues or bugs while implementing the edge flip operation. We used the check_for(...) debugging function to check which other elements in the mesh pointed to a given element, which helped ensure that all pointers were being set correctly. Overall, the implementation of the edge flip operation was straightforward and did not require any major debugging.
        </b>
        <p>
            YOUR RESPONSE GOES HERE
        </p>
        <br />


        <h3 align="middle">Part 5: Edge Split</h3>
        <p>
            To implement the edge split operation, we first checked if the edge was a boundary edge by checking if either of the neighboring faces was on a boundary loop. If it was a boundary edge, we simply returned immediately.
        </p>
        <p>
            Next, we created a new vertex at the midpoint of the edge, and assigned its position to the midpoint. We then created two new half-edges, one on either side of the split edge, and set their pointers correctly to create two new triangles. We also updated the pointers of all neighboring elements to point to the new elements created in the split operation.
        </p>
        <p>
            To ensure that all pointers of all elements were still valid after the edge split, we followed the steps outlined in the prompt for Part 4. We drew a simple mesh and wrote down a list of all elements, then drew the mesh after the split and wrote down a list of all elements in the modified mesh. We made sure to set all pointers of all elements in the modified mesh, not just the ones that had changed, to avoid missing a pointer.
        </p>
        <br />


        <b>
            Show screenshots of a mesh before and after some edge splits.
        </b>
        <p>
            YOUR RESPONSE GOES HERE
        </p>
        <br />


        <b>
            Show screenshots of a mesh before and after a combination of both edge splits and edge flips.
        </b>
        <p>
            YOUR RESPONSE GOES HERE
        </p>
        <br />


        <b>
            Write about your eventful debugging journey, if you have experienced one.
        </b>
        <p>
            YOUR RESPONSE GOES HERE
        </p>
        <br />


        <b>
            If you have implemented support for boundary edges, show screenshots of your implementation properly handling split operations on boundary edges.
        </b>
        <p>
            YOUR RESPONSE GOES HERE
        </p>
        <br />


        <h3 align="middle">Part 6: Loop Subdivision for Mesh Upsampling</h3>
        <p>
            In our implementation, we followed the recommended approach of updating vertex positions before subdividing the mesh. We looped over all vertices in the original mesh and calculated the new position for each vertex using the weighted average described in the instructions. We stored the new position in the newPosition member variable of each Vertex object. Then, we looped over all edges in the original mesh and calculated the new position for each midpoint using the same weighted average. We stored the new position in the newPosition member variable of each Edge object.
        </p>
        <p>
            Next, we looped over all edges in the original mesh and split them in any order. For each new vertex created by a split, we set its newPosition to the correct position calculated earlier. If the new vertex was created by splitting an edge on the boundary of the mesh, we marked it as not isNew. Otherwise, we marked it as isNew.
        </p>

        <p>
            Finally, we looped over all edges in the original mesh and flipped any new edge that connected an old vertex and a new vertex. For each existing vertex in the original mesh, we calculated its new position using the weighted average of its original position and the positions of its neighboring vertices, as described in the instructions. We stored the new position in the newPosition member variable of the Vertex object.
        </p>
        <br />


        <b>
            Take some notes, as well as some screenshots, of your observations on how meshes behave after loop subdivision. What happens to sharp corners and edges? Can you reduce this effect by pre-splitting some edges?
        </b>

        


        <p>
            After loop subdivision, sharp corners and edges become smoother and more rounded. This effect can be reduced by pre-splitting some edges in the original mesh, which adds more vertices to the mesh and creates a more even distribution of vertices. In general, pre-splitting edges that are close to sharp corners or edges can help preserve their sharpness after subdivision.
        </p>





        <br />


        <b>
            Load dae/cube.dae. Perform several iterations of loop subdivision on the cube. Notice that the cube becomes slightly asymmetric after repeated subdivisions. Can you pre-process the cube with edge flips and splits so that the cube subdivides symmetrically? Document these effects and explain why they occur. Also explain how your pre-processing helps alleviate the effects.
        </b>
        <p>
            When performing several iterations of loop subdivision on the cube mesh, we noticed that the cube became slightly asymmetric. This is because the original cube mesh has some edges that are not symmetrically placed with respect to their neighboring edges. To pre-process the cube mesh to achieve symmetric subdivision, we flipped and split some of these edges so that they were more symmetrically placed. Specifically, we flipped and split edges that were on the corners of the cube, and edges that were near the center of each face. After pre-processing, the cube subdivides more symmetrically and maintains its shape better after repeated subdivisions.
        </p>
        <br />


        <b>
            If you have implemented any extra credit extensions, explain what you did and document how they work with screenshots.
        </b>
        <p>
            YOUR RESPONSE GOES HERE
        </p>
        <br />


        <h3 align="middle">Part 7 (Optional, Possible Extra Credit)</h3>
        <b>
            Save your best polygon mesh as partsevenmodel.dae in your docs folder and show us a screenshot of the mesh in your write-up.
        </b>
        <p>
            YOUR RESPONSE GOES HERE
        </p>
        <br />


        <b>
            Include a series of screenshots showing your original mesh and your mesh after one and two rounds of subdivision. If you have used custom shaders, include screenshots of your mesh with those shaders applied as well.
        </b>
        <p>
            YOUR RESPONSE GOES HERE
        </p>
        <br />


        <b>
            Describe what you have done to enhance your mesh beyond the simple humanoid mesh described in the tutorial.
        </b>
        <p>
            YOUR RESPONSE GOES HERE
        </p>
        <br />


    </div></body>
</html>